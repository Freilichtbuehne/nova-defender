local function SpawnedPropCheck(ply, model, ent)
    if not Nova.getSetting("exploit_fix_propspawn", false) then return end

    if string.lower(ent:GetMaterial()) == "pp/copy" then
        ent:Remove()
    end
end

hook.Add("PlayerSpawnedProp", "nova_exploit_propspawn", SpawnedPropCheck)

local function MaterialCheck(ply, _, toolmode)
    if not Nova.getSetting("exploit_fix_material", false) then return end

    if toolmode:lower() == "material" then
        local tool = ply:GetActiveWeapon():GetToolObject()
        if string.lower(tool:GetClientInfo("override")) == "pp/copy" then return false end
    end
end

hook.Add("CanTool", "nova_exploit_material", MaterialCheck)

local function FadingDoorCheck(ply, trace, toolmode)
    if not Nova.getSetting("exploit_fix_fadingdoor", false) then return end
    if toolmode:lower() == "fading_door" and IsValid(trace.Entity) and trace.Entity:GetClass() == "gmod_light" and not Nova.isStaff(ply) then return false end
end

hook.Add("CanTool", "nova_exploit_fadingdoor", FadingDoorCheck)

local function PhysGunReloadCheck(wep, ply)
    if not Nova.getSetting("exploit_fix_physgunreload", false) then return end
    if not Nova.isStaff(ply) then return false end
end

hook.Add("OnPhysgunReload", "nova_exploit_physgunreload", PhysGunReloadCheck)

local function BouncyBallCheck(ply, trace, toolmode)
    if not Nova.getSetting("exploit_fix_bouncyball", false) then return end
    if toolmode == "weld" and IsValid(trace.Entity) and trace.Entity:GetClass() == "sent_ball" then return false end
end

hook.Add("CanTool", "nova_exploit_bouncyball", BouncyBallCheck)

local function PreventBhop(ply)
    if not Nova.getSetting("exploit_fix_bhop", false) then return end
    // you can add your own exceptions here ;)
    // if Nova.isProtected(ply) then return end
    local vel = ply:GetVelocity()
    local speed = vel:Length()
    local maxSpeed = ply:GetMaxSpeed()

    if speed > maxSpeed then
        vel:Normalize()
        local maxVel = vel * maxSpeed
        local newVel = maxVel - ply:GetVelocity()
        newVel.z = 0
        ply:SetVelocity(newVel)
    end
    // This is a bit more aggressive method of preventing bhopping
    /*if ply:GetVelocity():Length() > 0 then
        local vel = ply:GetVelocity()
        vel.z = 0
        ply:SetVelocity(vel * -0.5)
    end*/
end

hook.Add("OnPlayerHitGround", "nova_exploit_nobhop", PreventBhop)

local function LoadServerSecure()
    if not Nova.getSetting("exploit_fix_serversecure", false) then return end

    local binaryExists = false
    // check if binary module exists
    local f1, _ = file.Find("lua/bin/gmsv_serversecure*.dll", "GAME")

    if #f1 > 0 or util.IsBinaryModuleInstalled( "serversecure.core" ) then
        binaryExists = true
    end

    local luaFileExists = false
    // check if lua module exists
    local f2, _ = file.Find("lua/includes/modules/serversecure.lua", "GAME")

    if #f2 > 0 then
        luaFileExists = true
    end

    local correctArch = false

    // check if we are running 32 bit
    if jit.arch == "x86" then
        correctArch = true
    end

    if binaryExists and luaFileExists and correctArch then
        require("serversecure")

        if serversecure then
            //serversecure.EnableFirewallWhitelist(boolean) // enable "firewall" whitelist, any client not in the whitelist doesn't see the server
            //serversecure.AddWhitelistIP(ip_in_integer_format) // add an IP to the whitelist
            //serversecure.RemoveWhitelistIP(ip_in_integer_format) // remove an IP from the whitelist
            //serversecure.ResetWhitelist() // reset the whitelist
            //serversecure.EnableFirewallBlacklist(boolean) // enable "firewall" blacklist, any client in the blacklist doesn't see the server
            //serversecure.AddBlacklistIP(ip_in_integer_format) // add an IP to the blacklist
            //serversecure.RemoveBlacklistIP(ip_in_integer_format) // remove an IP from the blacklist
            //serversecure.ResetBlacklist() // reset the blacklist
            serversecure.EnableFileValidation(true) // validates files requested by clients for download
            serversecure.EnablePacketValidation(true) // validates packets for having correct types, size, content, etc.
            serversecure.EnableInfoCache(true) // enable A2S_INFO response cache
            serversecure.SetInfoCacheTime(5) // seconds for cache to live (default is 5 seconds)
            serversecure.EnableQueryLimiter(true) // enable query limiter (similar to Source's one but all handled on the same place)
            serversecure.SetMaxQueriesWindow(60) // timespan over which to average query counts from IPs (default is 30 seconds)
            serversecure.SetMaxQueriesPerSecond(1) // maximum queries per second from a single IP (default is 1 per second)
            serversecure.SetGlobalMaxQueriesPerSecond(50) // maximum total queries per second (default is 60 per second)
            Nova.log("s", "Serversecure module enabled")
        end
    else
        local reason = ""

        if not binaryExists then
            reason = string.format("%s%s", reason, "binary module not found, ")
        end

        if not luaFileExists then
            reason = string.format("%s%s", reason, "lua module (serversecure.lua) not found, ")
        end

        if not correctArch then
            reason = string.format("%s%s", reason, "not running 32 bit, ")
        end

        // remove last comma
        reason = string.sub(reason, 1, -3)
        Nova.log("e", string.format("Failed to autoload serversecure module: %s", reason))
    end
end


if not Nova.defaultSettingsLoaded then
    hook.Add("nova_mysql_config_loaded", "exploit_load", function() timer.Simple(0, LoadServerSecure) end)
else
    timer.Simple(0, LoadServerSecure)
end